define ([
  'mydash'
  'constants'
  'constructors'
  'utilities'
  'extractors'
  'chessman'
  'assertions'
], (_, c, g, u, x, chessman-fns, v) ->

  home-ranks = {}
  home-ranks[c.black] = 1
  home-ranks[c.white] = 6

  directions = {}
  directions[c.black] = 1
  directions[c.white] = -1

  promotion-ranks = {}
  promotion-ranks[c.black] = 7
  promotion-ranks[c.white] = 0

  advancing-2-squares? = (src, tgt) ->
    # Start testing mode.
    v.vow-all-positions [src, tgt]
    # End testing mode.
    _.abs (u.rank-difference (src, tgt)) > 1

  at-home-rank? = (color, rank) ->
    home-ranks[color] == rank

  at-promotion-rank? = (color, rank) ->
    promotion-ranks[color] == rank

  behind = (dir, position) ->
    # Start testing mode.
    v.vow-pawn-direction dir
    v.vow-position position
    # End testing mode.

    dir = -1 * dir
    [rank, file] = x.rank-&-file-from position

    [rank + dir, file]

  direction-for = \color ->
    directions[color]

  get-diagonal-positions = (rank, file, dir) ->
    gen-pos = g.generate-position!.bind (null, rank + dir)
    _.filter u.inessent? (_.map gen-pos [file - 1, file + 1])

  get-diag-attacks = (board, rank, file, color, dir, passant) ->
    # Start testing mode.
    v.vow-board board
    v.vow-all-position-components [rank, file]
    v.vow-color color
    v.vow-passant-position passant
    v.vow-pawn-direction dir
    # End testing mode.

    foe-present? = \pos -> u.opponent? [color, color-at pos]
    passant?     = u.same-position? passant
    available?   = _.or [foe-present?, passant?]
    color-at     = x.color-at board
    diag-attacks = get-diagonal-positions (rank, file, dir)
    
    _.filter available? diag-attacks

  get-fwd-moves = (board, rank, file, color, dir) ->
    # Start testing mode.
    v.vow-board board
    v.vow-all-position-components [rank, file]
    v.vow-color color
    v.vow-pawn-direction dir
    # End testing mode.

    fwd-moves  = []
    tgt1       = g.generate-position (rank + dir, file)
    tgt1-color = x.color-at board tgt1

    return fwd-moves unless u.color-absent? tgt1-color

    fwd-moves.push tgt1

    return fwd-moves unless at-home-rank? (color, rank)

    # Because, for the vast majority of the game, pawns may
    # only advance one square, 'g.generate-position',
    # 'x.color-at board', and 'u.color-absent?' are not memoized
    # with local variables.

    tgt2       = g.generate-position (rank + 2 * dir, file)
    tgt2-color = x.color-at board tgt2

    return fwd-moves unless u.color-absent? tgt2-color

    fwd-moves.push tgt2

    return fwd-moves

  getPotentialKingAttacks = \board \src ->
    # Start testing mode.
    v.vow-board board
    v.vow-position src
    # End testing mode.

    [rank, file] = x.rank-&-file-from src

    color   = x.color-at board src
    dir     = direction-for color

    get-diagonal-positions (rank, file, dir)

  getPotentialKingAttacks2 = (bd, src) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-position src
    # End testing mode.

    color = x.color-at bd src

    [rank, file]   = x.rank-&-file-from src
    pawn-direction = direction-for color

    get-diagonal-positions (rank, file, pawn-direction)
    

  # TODO: Only filter forward moves with 'u.inessent?'.
  getPotentialMoves = \chart2 ->
    # Start testing mode.
    v.vow-chart2 chart2
    # End testing mode.

    bd           = x.board-from chart2
    src          = x.position-from chart2
    [rank, file] = x.rank-&-file-from src
    color        = x.color-at bd src
    dir          = direction-for color
    passant      = x.passant-from chart2

    potential-moves = _.meld [
      get-fwd-moves (bd, rank, file, color, dir)
      get-diag-attacks (bd, rank, file, color, dir, passant)
    ]

    _.filter u.inessent? potential-moves

  getPotentialMoves2 = (bd, src, rts, passant) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-position src
    v.vow-passant-position passant
    # End testing mode.

    color = x.color-at bd src
    [rank, file] = x.rank-&-file-from src
    dir = direction-for color

    moves = Array.concat (
      get-fwd-moves    (bd, rank, file, color, dir)
      get-diag-attacks (bd, rank, file, color, dir, passant)
    )

    _.filter u.inessent? moves

  modifyCastlingRights = \chart2 ->
    # Start testing mode.
    v.vow-chart2 chart2
    # End testing mode.

    x.castling-rights-from chart2

  move = \chart2 \tgt ->
    # Start testing mode.
    v.vow-chart2 chart2
    v.vow-position tgt
    # End testing mode.

    board        = x.board-from chart2
    src          = x.position-from chart2
    src-chessman = x.square-at board src
    passant      = x.passant-from chart2

    bd-w/-duplicate-piece = u.replace (src-chessman, board, tgt)

    result = u.replace (c.empty-square, bd-w/-duplicate-piece, src)

    return result if u.passant-position-unset? passant

    color        = x.color-at board src
    dir          = direction-for color

    u.replace (c.empty-square, result, behind (dir, passant))

  delete-passed-pawn = (board, color, passant) ->
    direction = direction-for color
    u.replace (c.empty-square, board, behind (direction, passant))

  move2 = (bd, src, rts, passant) -> \tgt ->
    # Start testing mode.
    v.vow-board bd
    v.vow-all-positions [src, tgt]
    v.vow-passant-position passant
    # End testing mode.

    bd-after-basic-move = pf.basicMove2 (bd, src) tgt

    if u.passant-position-unset? passant
      bd-after-basic-move
    else
      color = x.color-at bd src
      delete-passed-pawn (bd-after-basic-move, color, passant)

  setPassantPosition = (chart2, tgt) ->
    # Start testing mode.
    v.vow-chart2 chart2
    v.vow-position tgt
    # End testing mode.

    src = x.position-from chart2

    if advancing-2-squares? (src, tgt)
      bd    = x.board-from chart2
      color = x.color-at bd src
      dir   = direction-for color
      behind (dir, tgt)
    else
      c.unset-passant-pos

  setPassantPosition2 = (pawn-color, src, tgt) ->
    # Start testing mode.
    v.vow-color pawn-color
    v.vow-all-positions [src, tgt]
    # End testing mode.

    if advancing-2-squares? (src, tgt)
      dir = direction-for pawn-color
      behind (dir, tgt)
    else
      c.unset-passant-pos

  setPromotionPosition = (chart2, tgt) ->
    # Start testing mode.
    v.vow-chart2 chart2
    v.vow-position tgt
    # End testing mode.

    bd     = x.board-from chart2
    src    = x.position-from chart2
    color  = x.color-at bd src
    [rank] = x.rank-&-file-from tgt

    if at-promotion-rank? (color, rank) then tgt else c.unset-promotion-pos

  setPromotionPosition2 = (pawn-color, tgt) ->
    # Start testing mode.
    v.vow-color pawn-color
    v.vow-position tgt
    # End testing mode.

    [tgt-rank] = x.rank-&-file-from tgt

    if at-promotion-rank? (pawn-color, tgt-rank)
      tgt
    else
      c.unset-promotion-pos

  pf = public-fns = _.defaults [chessman-fns] {
    getPotentialKingAttacks
    getPotentialMoves
    modifyCastlingRights
    move
    setPassantPosition
    setPromotionPosition
    getPotentialKingAttacks2
    getPotentialMoves2
    move2
    setPassantPosition2
    setPromotionPosition2
  }

  return public-fns

)
