define ([
  'base-helpers'
  'constants'
  'utilities'
  'extractors'
  'slider'
  'king'
  'rook'
  'knight'
  'pawn'
  'assertions'
], (_, c, u, x, slider-fns, king-fns, rook-fns, knight-fns, pawn-fns, v) ->

  dispatch-table = {}
  dispatch-table[c.king  ] = king-fns
  dispatch-table[c.queen ] = slider-fns
  dispatch-table[c.rook  ] = rook-fns
  dispatch-table[c.bishop] = slider-fns
  dispatch-table[c.knight] = knight-fns
  dispatch-table[c.pawn  ] = pawn-fns

  add-msg = (ctx, msg) ->
    { board, player, castlingRights, passantPosition } = ctx
    { board, player, castlingRights, passantPosition, message : msg }

  call = \fn-name \chessman-type ->
    # Start testing mode.
    v.vow-string fn-name
    v.vow-chessman-type chessman-type
    # End testing mode.

    dispatch-table[chessman-type][fn-name]

  checkmate? = (bd, passant, color) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-passant-position passant
    v.vow-color color
    # End testing mode.

    ally-positions = x.chessman-positions-from (bd, color)

    for ally-pos in ally-positions
      potential-moves =
        getPotentialMoves (bd, ally-pos, c.no-castling-rts, passant)

      for potential-mv in potential-moves
        new-bd = move (bd, ally-pos, passant) potential-mv
        return false unless in-check? (new-bd, color)

    true

  contains = (potential-positions, tgt) ->
    potential-positions.some (u.same-position? tgt)

  extract-props = \ctx ->
    { board, player, castlingRights, passantPosition } = ctx
    [board, player, castlingRights, passantPosition]

  game-completed-response = ->
    message : 'checkmate'

  game-continues-response = \new-ctx ->
    add-msg (new-ctx, 'check')

  generate-new-ctx = (new-bd, orig-ctx, src, tgt) ->
    [orig-bd, player, rts] = extract-props orig-ctx

    board  : new-bd
    player : u.opposing-color player
    castlingRights    : modifyCastlingRights (orig-bd, src, rts)
    passantPosition   : setPassantPosition   (orig-bd, src, tgt)
    promotionPosition : setPromotionPosition (orig-bd, src, tgt)

  getPotentialKingAttacks = (bd, src) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-position src
    # End testing mode.

    type = x.chessman-type-at bd src
    call 'getPotentialKingAttacks' type (bd, src, type)

  getPotentialMoves = (bd, src, rts, passant) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-position src
    v.vow-castling-right-set rts
    v.vow-passant-position passant
    # End testing mode.

    type = x.chessman-type-at bd src
    call 'getPotentialMoves' type (bd, src, rts, passant, type)

  in-check? = (board, color) ->
    # Start testing mode.
    v.vow-board board
    v.vow-color color
    # End testing mode.

    king-pos = king-position-for (board, color)
    vuln-positions = vulnerable-positions-for (board, color)
    contains (vuln-positions, king-pos)

  king-position-for = (board, color) ->
    # Start testing mode.
    v.vow-board board
    v.vow-color color
    # End testing mode.

    king = if u.black? color then c.black-king else c.white-king
    u.to-2d (board.indexOf king)

  king-safe-response = \new-ctx ->
    # Coupling.
    { board, player } = new-ctx
    
    if opponent-in-check? (board, player)
      possible-checkmate-response (new-ctx)
    else
      new-ctx

  king-unsafe-response = \ctx ->
    add-msg (ctx, 'illegal move')

  modifyCastlingRights = (bd, src, rts) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-position src
    v.vow-castling-right-set rts
    # End testing mode.

    type = x.chessman-type-at bd src
    call 'modifyCastlingRights' type (rts, src)

  move = (bd, src, passant) -> \tgt ->
    # Start testing mode.
    v.vow-board bd
    v.vow-all-positions [src, tgt]
    v.vow-passant-position passant
    # End testing mode.

    type = x.chessman-type-at bd src
    call 'move' type (bd, src, passant) tgt

  move-illegal-response = \ctx ->
    add-msg (ctx, 'illegal move')

  move-legal? = (bd, src, rts, passant) -> \tgt ->
    # Start testing mode.
    v.vow-board bd
    v.vow-all-positions [src, tgt]
    v.vow-castling-right-set rts
    v.vow-passant-position passant
    # End testing mode.

    type  = x.chessman-type-at bd src
    potential-tgts = getPotentialMoves (bd, src, rts, passant)
    
    contains (potential-tgts, tgt)

  # Note: 'rts' is not necessary.
  move-legal-response = (orig-ctx, src, tgt) ->
    [bd, player, rts, passant] = extract-props orig-ctx

    new-bd = move (bd, src, passant) tgt

    if in-check? (new-bd, player)
      king-unsafe-response (orig-ctx)
    else
      new-ctx = generate-new-ctx (new-bd, orig-ctx, src, tgt)
      king-safe-response (new-ctx)

  opponent-in-check? = in-check?

  possible-checkmate-response = \new-ctx ->
    # Coupling.
    { board, player, passantPosition } = new-ctx

    if checkmate? (board, passantPosition, player)
      game-completed-response ()
    else
      game-continues-response (new-ctx)

  query-game-service = (ctx, src, tgt) ->
    [bd, player, rts, passant] = extract-props ctx

    if move-legal? (bd, src, rts, passant) tgt
      move-legal-response (ctx, src, tgt)
    else
      move-illegal-response ctx

  setPassantPosition = (bd, src, tgt) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-all-positions [src, tgt]
    # End testing mode.

    chessman = x.square-at bd src
    type     = x.chessman-type-of chessman
    color    = x.color-of chessman

    call 'setPassantPosition' type (color, src, tgt)

  setPromotionPosition = (bd, src, tgt) ->
    # Start testing mode.
    v.vow-board bd
    v.vow-all-positions [src, tgt]
    # End testing mode.

    chessman = x.square-at bd src
    type     = x.chessman-type-of chessman
    color    = x.color-of chessman

    call 'setPromotionPosition' type (color, tgt)

  vulnerable-positions-for = (board, color) ->
    # Start testing mode.
    v.vow-board board
    v.vow-color color
    # End testing mode.

    foe-color     = u.opposing-color (color)
    foe-positions = x.chessman-positions-from (board, foe-color)

    get-potential-king-attacks = \pos ->
      getPotentialKingAttacks (board, pos)

    Array.concat.apply (null, (foe-positions.map get-potential-king-attacks))

  # Start testing mode.

  test-mode = {
    call
    checkmate?
    getPotentialKingAttacks
    getPotentialMoves
    in-check?
    king-position-for
    modifyCastlingRights
    move
    move-legal?
    query-game-service
    setPassantPosition
    setPromotionPosition
    vulnerable-positions-for
  }

  return test-mode

  # End testing mode.

  # Start production mode.
  # return { query-game-service }
  # End production mode.


)
