define (['jFns', 'constants', 'assertions'], (j, c, v) ->

  {
    descr
    xdescr
    t
    xt
    test-spec
    to-throw
    to-be
    to-equal
    to-be-true
    to-be-false
    satisfies
    contravenes
    throws
    each-satisfies
    each-contravenes
    each-throws
    to-be-fn
    test-predicate
    test-transformation
    test-throwing-transformation
    gen-pred-guards
  } = j

  descr 'test assertions.cough' (->

    bd = '--------------------Q-------------------------------------------'
    rts = c.full-castling-rts
    passant = c.unset-passant-pos

    ctx = { board : bd, castlingRights : rts, passantPosition : passant }

    src = [2, 4]
    tgt = [5, 4]
    
    path = [tgt, src]

    chart = [ctx, path]

    t 'test v.vow-board' (->
      fn = v.vow-board
      to-throw fn ctx
      to-equal bd (fn bd)
    )

    t 'test v.vow-bounded' (->
      fn = v.vow-bounded
      to-throw fn 10
      to-equal (4) (fn 4)
    )

    t 'test v.castling-right' (->
      fn = v.vow-castling-right
      to-throw fn 'X'
      to-equal ('K') (fn 'K')
    )

    t 'test v.castling-righ-set' (->
      fn = v.vow-castling-right-set 
      to-throw fn 'KQxkq'
      to-equal ('KQk') (fn 'KQk')
    )

    t 'test v.chart' (->
      fn = v.vow-chart
      to-throw fn bd
      to-equal chart (fn chart)
    )

    t 'test v.vow-chessman' (->
      fn = v.vow-chessman
      to-throw fn 'X'
      to-equal c.white-knight (fn c.white-knight)
    )

    t 'test v.vow-chessman-type' (->
      fn = v.vow-chessman-type 
      to-throw fn c.white-knight
      to-equal c.knight (fn c.knight)
    )

    t 'test v.vow-color' (->
      fn = v.vow-color
      to-throw fn 'x'
      to-equal c.white (fn c.white)
    )

    t 'test v.vow-color-pair' (->
      fn = v.vow-color-pair
      to-throw fn ['x', c.white]

      color-pair = [c.white, c.black]
      to-equal color-pair (fn color-pair)
    )

    t 'test v.vow-context' (->
      fn = v.vow-context
      to-throw fn bd
      to-equal ctx (fn ctx)
    )

    t 'test v.vow-index' (->
      fn = v.vow-index
      to-throw fn 100
      to-equal 62 (fn 62)
    )

    t 'test v.vow-integral-pair' (->
      fn = v.vow-integral-pair 
      to-throw fn [5, 5.5]
      i-pair = [7, 4]
      to-equal i-pair (fn i-pair)
    )

    t 'test v.vow-map' (->
      fn = v.vow-map
      to-throw fn ctx
      map = [bd, path]
      to-equal map (fn map)
    )

    t 'test v.vow-pair' (->
      fn = v.vow-pair
      to-throw fn [1, 'a', true]
      pair = [1, 'a']
      to-equal pair (fn pair)
    )

    t 'test v.vow-passant-position' (->
      fn = v.vow-passant-position
      to-throw fn [1, 8]
      to-equal passant (fn passant)
    )

    t 'test v.vow-path' (->
      fn = v.vow-path
      to-throw fn ([1, 2, 3])
      path = [[4, 2], [1, 5]]
      to-equal path (fn path)
    )

    t 'test v.vow-player' (->
      fn = v.vow-player
      to-throw fn 'x'
      player = c.white
      to-equal player (fn player)
    )

    t 'test v.vow-position' (->
      fn = v.vow-position
      to-throw fn passant
      to-equal src (fn src)
    )

    t 'test v.vow-rook' (->
      fn = v.vow-rook
      to-throw fn c.white-king
      to-equal c.white-rook (fn c.white-rook)
    )

    t 'test v.vow-setting' (->
      fn = v.vow-setting

      invalid-bd = '-------------'
      to-throw fn [invalid-bd, tgt]

      setting = [bd, src]
      to-equal setting (fn setting)
    )

    t 'test v.vow-square' (->
      fn = v.vow-square
      to-throw fn 'x'
      to-equal c.empty-square (fn c.empty-square)
      to-equal c.black-bishop (fn c.black-bishop)
    )

    t 'test v.vow-chessman-type' (->
      fn = v.vow-chessman-type
      to-throw fn 'x'
      to-equal c.pawn (fn c.pawn)
    )

  )

)
